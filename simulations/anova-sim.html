<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ANOVA Simulation</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .scenario-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }
        .scenario-btn {
            background-color: #e9ecef;
            color: #333;
            border: 2px solid transparent;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .scenario-btn.active {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .value-display {
            text-align: center;
            color: #007bff;
            font-weight: bold;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .groups-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .group-box {
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #ddd;
        }
        .group-1 { background-color: #e3f2fd; border-color: #2196f3; }
        .group-2 { background-color: #fce4ec; border-color: #e91e63; }
        .group-3 { background-color: #e8f5e9; border-color: #4caf50; }
        .group-4 { background-color: #fff3e0; border-color: #ff9800; }
        .group-mean {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
        }
        #chart {
            margin: 20px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .anova-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: white;
        }
        .anova-table th {
            background-color: #007bff;
            color: white;
            padding: 12px;
            text-align: left;
        }
        .anova-table td {
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }
        .anova-table tr:hover {
            background-color: #f5f5f5;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .stat-box {
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: center;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .decision-box {
            margin-top: 20px;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
        }
        .reject { background-color: #d4edda; color: #155724; }
        .fail-reject { background-color: #f8d7da; color: #721c24; }
        .post-hoc {
            margin-top: 20px;
            padding: 20px;
            background-color: #fff3cd;
            border-radius: 8px;
            border: 1px solid #ffeeba;
        }
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .comparison-box {
            padding: 10px;
            background-color: white;
            border-radius: 5px;
            text-align: center;
            font-size: 14px;
        }
        .sig { background-color: #d4edda; }
        .not-sig { background-color: #f8f9fa; }
        .explanation {
            margin-top: 30px;
            padding: 20px;
            background-color: #e8f4f8;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .assumptions {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f8ff;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ANOVA (Analysis of Variance) Simulation</h1>
        
        <div class="scenario-selector">
            <button class="scenario-btn active" onclick="setScenario('one-way')">One-Way ANOVA</button>
            <button class="scenario-btn" onclick="setScenario('two-way')">Two-Way ANOVA (Coming Soon)</button>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="numGroups">Number of Groups:</label>
                <input type="range" id="numGroups" min="3" max="5" value="4" step="1">
                <div class="value-display" id="numGroupsValue">4</div>
            </div>
            
            <div class="control-group">
                <label for="sampleSize">Sample Size per Group:</label>
                <input type="range" id="sampleSize" min="10" max="50" value="20" step="5">
                <div class="value-display" id="sampleSizeValue">20</div>
            </div>
            
            <div class="control-group">
                <label for="grandMean">Grand Mean:</label>
                <input type="range" id="grandMean" min="40" max="60" value="50" step="1">
                <div class="value-display" id="grandMeanValue">50</div>
            </div>
            
            <div class="control-group">
                <label for="effectSize">Effect Size (η²):</label>
                <input type="range" id="effectSize" min="0" max="0.5" value="0.15" step="0.01">
                <div class="value-display" id="effectSizeValue">0.15</div>
            </div>
            
            <div class="control-group">
                <label for="withinStd">Within-Group Std Dev:</label>
                <input type="range" id="withinStd" min="1" max="20" value="10" step="1">
                <div class="value-display" id="withinStdValue">10</div>
            </div>
            
            <div class="control-group">
                <label for="alpha">Significance Level (α):</label>
                <input type="range" id="alpha" min="0.01" max="0.10" value="0.05" step="0.01">
                <div class="value-display" id="alphaValue">0.05</div>
            </div>
        </div>
        
        <div style="text-align: center;">
            <button onclick="generateData()">Generate New Data</button>
            <button onclick="runANOVA()">Run ANOVA Test</button>
            <button onclick="runSimulation()">Test Assumptions (100 runs)</button>
        </div>
        
        <div id="groupsDisplay" class="groups-container"></div>
        
        <canvas id="chart" width="900" height="400"></canvas>
        
        <div id="anovaTableContainer" style="display: none;">
            <h3>ANOVA Table</h3>
            <table class="anova-table">
                <thead>
                    <tr>
                        <th>Source</th>
                        <th>Sum of Squares</th>
                        <th>df</th>
                        <th>Mean Square</th>
                        <th>F-statistic</th>
                        <th>p-value</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Between Groups</td>
                        <td id="ssBetween">-</td>
                        <td id="dfBetween">-</td>
                        <td id="msBetween">-</td>
                        <td rowspan="2" style="text-align: center; font-weight: bold;" id="fStat">-</td>
                        <td rowspan="2" style="text-align: center; font-weight: bold;" id="pValue">-</td>
                    </tr>
                    <tr>
                        <td>Within Groups</td>
                        <td id="ssWithin">-</td>
                        <td id="dfWithin">-</td>
                        <td id="msWithin">-</td>
                    </tr>
                    <tr style="font-weight: bold;">
                        <td>Total</td>
                        <td id="ssTotal">-</td>
                        <td id="dfTotal">-</td>
                        <td>-</td>
                        <td>-</td>
                        <td>-</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">Effect Size (η²)</div>
                <div class="stat-value" id="etaSquared">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Power</div>
                <div class="stat-value" id="power">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Grand Mean</div>
                <div class="stat-value" id="observedGrandMean">-</div>
            </div>
        </div>
        
        <div id="decisionBox" class="decision-box" style="display: none;"></div>
        
        <div id="postHoc" class="post-hoc" style="display: none;">
            <h3>Post-Hoc Analysis (Tukey HSD)</h3>
            <p>Pairwise comparisons between groups:</p>
            <div id="comparisonGrid" class="comparison-grid"></div>
        </div>
        
        <div id="assumptions" class="assumptions" style="display: none;">
            <h3>Assumption Checks</h3>
            <div id="assumptionResults"></div>
        </div>
        
        <div class="explanation">
            <h3>Understanding ANOVA</h3>
            <p>Analysis of Variance (ANOVA) tests whether there are statistically significant differences between the means of three or more independent groups.</p>
            
            <p><strong>Key Concepts:</strong></p>
            <ul>
                <li><strong>Null Hypothesis (H₀):</strong> All group means are equal (μ₁ = μ₂ = μ₃ = ...)</li>
                <li><strong>Alternative Hypothesis (H₁):</strong> At least one group mean differs from the others</li>
                <li><strong>F-statistic:</strong> Ratio of between-group variance to within-group variance</li>
                <li><strong>Effect Size (η²):</strong> Proportion of total variance explained by group differences</li>
                <li><strong>Post-hoc tests:</strong> If ANOVA is significant, these identify which specific groups differ</li>
            </ul>
            
            <p><strong>ANOVA Assumptions:</strong></p>
            <ul>
                <li>Independence of observations</li>
                <li>Normality within each group</li>
                <li>Homogeneity of variance (equal variances across groups)</li>
            </ul>
            
            <p><strong>When to Use ANOVA:</strong></p>
            <ul>
                <li>Comparing means of 3+ groups (for 2 groups, use t-test)</li>
                <li>One continuous dependent variable</li>
                <li>One categorical independent variable (factor)</li>
            </ul>
        </div>
    </div>

    <script>
        let groupData = [];
        const colors = ['#2196f3', '#e91e63', '#4caf50', '#ff9800', '#9c27b0'];
        
        // Update slider values
        document.querySelectorAll('input[type="range"]').forEach(slider => {
            slider.addEventListener('input', (e) => {
                const valueDisplay = document.getElementById(e.target.id + 'Value');
                valueDisplay.textContent = e.target.value;
                if (e.target.id === 'numGroups') {
                    generateData();
                }
            });
        });
        
        function setScenario(type) {
            if (type === 'two-way') {
                alert('Two-Way ANOVA simulation coming soon!');
                return;
            }
            document.querySelectorAll('.scenario-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }
        
        function normalRandom(mean, std) {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return mean + std * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }
        
        function generateGroupMeans(numGroups, grandMean, effectSize, withinStd) {
            // Generate group means with specified effect size
            const means = [];
            const maxDeviation = withinStd * Math.sqrt(effectSize / (1 - effectSize)) * 2;
            
            for (let i = 0; i < numGroups; i++) {
                const angle = (2 * Math.PI * i) / numGroups;
                const deviation = maxDeviation * Math.sin(angle);
                means.push(grandMean + deviation);
            }
            
            return means;
        }
        
        function generateData() {
            const numGroups = parseInt(document.getElementById('numGroups').value);
            const sampleSize = parseInt(document.getElementById('sampleSize').value);
            const grandMean = parseFloat(document.getElementById('grandMean').value);
            const effectSize = parseFloat(document.getElementById('effectSize').value);
            const withinStd = parseFloat(document.getElementById('withinStd').value);
            
            const groupMeans = generateGroupMeans(numGroups, grandMean, effectSize, withinStd);
            groupData = [];
            
            for (let i = 0; i < numGroups; i++) {
                const data = [];
                for (let j = 0; j < sampleSize; j++) {
                    data.push(normalRandom(groupMeans[i], withinStd));
                }
                groupData.push({
                    name: `Group ${i + 1}`,
                    data: data,
                    mean: data.reduce((a, b) => a + b, 0) / data.length,
                    std: Math.sqrt(data.reduce((a, b) => a + Math.pow(b - data.reduce((c, d) => c + d, 0) / data.length, 2), 0) / (data.length - 1))
                });
            }
            
            updateGroupsDisplay();
            drawBoxPlot();
        }
        
        function updateGroupsDisplay() {
            const container = document.getElementById('groupsDisplay');
            container.innerHTML = '';
            
            groupData.forEach((group, index) => {
                const groupBox = document.createElement('div');
                groupBox.className = `group-box group-${(index % 4) + 1}`;
                groupBox.innerHTML = `
                    <h4>${group.name}</h4>
                    <div class="group-mean">${group.mean.toFixed(2)}</div>
                    <div>SD: ${group.std.toFixed(2)}</div>
                    <div>n = ${group.data.length}</div>
                `;
                container.appendChild(groupBox);
            });
        }
        
        function runANOVA() {
            if (groupData.length === 0) {
                generateData();
            }
            
            // Calculate ANOVA
            const allData = groupData.flatMap(g => g.data);
            const grandMean = allData.reduce((a, b) => a + b, 0) / allData.length;
            const n = allData.length;
            const k = groupData.length;
            
            // Sum of Squares
            let ssTotal = 0;
            let ssBetween = 0;
            let ssWithin = 0;
            
            // Total SS
            allData.forEach(value => {
                ssTotal += Math.pow(value - grandMean, 2);
            });
            
            // Between-group SS
            groupData.forEach(group => {
                ssBetween += group.data.length * Math.pow(group.mean - grandMean, 2);
            });
            
            // Within-group SS
            groupData.forEach(group => {
                group.data.forEach(value => {
                    ssWithin += Math.pow(value - group.mean, 2);
                });
            });
            
            // Degrees of freedom
            const dfBetween = k - 1;
            const dfWithin = n - k;
            const dfTotal = n - 1;
            
            // Mean squares
            const msBetween = ssBetween / dfBetween;
            const msWithin = ssWithin / dfWithin;
            
            // F-statistic
            const fStat = msBetween / msWithin;
            
            // P-value (using F-distribution approximation)
            const pValue = 1 - fCDF(fStat, dfBetween, dfWithin);
            
            // Effect size
            const etaSquared = ssBetween / ssTotal;
            
            // Update ANOVA table
            document.getElementById('anovaTableContainer').style.display = 'block';
            document.getElementById('ssBetween').textContent = ssBetween.toFixed(2);
            document.getElementById('ssWithin').textContent = ssWithin.toFixed(2);
            document.getElementById('ssTotal').textContent = ssTotal.toFixed(2);
            document.getElementById('dfBetween').textContent = dfBetween;
            document.getElementById('dfWithin').textContent = dfWithin;
            document.getElementById('dfTotal').textContent = dfTotal;
            document.getElementById('msBetween').textContent = msBetween.toFixed(2);
            document.getElementById('msWithin').textContent = msWithin.toFixed(2);
            document.getElementById('fStat').textContent = fStat.toFixed(3);
            document.getElementById('pValue').textContent = pValue.toFixed(4);
            
            // Update stats
            document.getElementById('etaSquared').textContent = etaSquared.toFixed(3);
            document.getElementById('observedGrandMean').textContent = grandMean.toFixed(2);
            
            // Decision
            const alpha = parseFloat(document.getElementById('alpha').value);
            const reject = pValue < alpha;
            const decisionBox = document.getElementById('decisionBox');
            decisionBox.style.display = 'block';
            decisionBox.className = reject ? 'decision-box reject' : 'decision-box fail-reject';
            decisionBox.textContent = reject ? 
                'Reject H₀ - At least one group mean is significantly different' : 
                'Fail to reject H₀ - No significant differences between group means';
            
            // Post-hoc analysis if significant
            if (reject) {
                runPostHoc();
            } else {
                document.getElementById('postHoc').style.display = 'none';
            }
            
            // Calculate power
            calculatePower(etaSquared, n, k, alpha);
        }
        
        function runPostHoc() {
            const postHocDiv = document.getElementById('postHoc');
            postHocDiv.style.display = 'block';
            
            const comparisonGrid = document.getElementById('comparisonGrid');
            comparisonGrid.innerHTML = '';
            
            const msWithin = parseFloat(document.getElementById('msWithin').textContent);
            const alpha = parseFloat(document.getElementById('alpha').value);
            
            // Tukey HSD critical value (approximation)
            const k = groupData.length;
            const dfWithin = groupData.reduce((sum, g) => sum + g.data.length, 0) - k;
            const qCrit = getTukeyCritical(k, dfWithin, alpha);
            
            // Pairwise comparisons
            for (let i = 0; i < groupData.length - 1; i++) {
                for (let j = i + 1; j < groupData.length; j++) {
                    const diff = Math.abs(groupData[i].mean - groupData[j].mean);
                    const se = Math.sqrt(msWithin * (1/groupData[i].data.length + 1/groupData[j].data.length));
                    const hsd = qCrit * se / Math.sqrt(2);
                    
                    const significant = diff > hsd;
                    
                    const compBox = document.createElement('div');
                    compBox.className = `comparison-box ${significant ? 'sig' : 'not-sig'}`;
                    compBox.innerHTML = `
                        <strong>${groupData[i].name} vs ${groupData[j].name}</strong><br>
                        Diff: ${diff.toFixed(2)}<br>
                        ${significant ? 'Significant' : 'Not significant'}
                    `;
                    comparisonGrid.appendChild(compBox);
                }
            }
        }
        
        function runSimulation() {
            const numGroups = parseInt(document.getElementById('numGroups').value);
            const sampleSize = parseInt(document.getElementById('sampleSize').value);
            const grandMean = parseFloat(document.getElementById('grandMean').value);
            const withinStd = parseFloat(document.getElementById('withinStd').value);
            const alpha = parseFloat(document.getElementById('alpha').value);
            
            let typeIErrors = 0;
            const variances = [];
            
            // Run 100 simulations with no effect (all means equal)
            for (let sim = 0; sim < 100; sim++) {
                const simData = [];
                
                for (let i = 0; i < numGroups; i++) {
                    const data = [];
                    for (let j = 0; j < sampleSize; j++) {
                        data.push(normalRandom(grandMean, withinStd));
                    }
                    simData.push(data);
                    variances.push(data.reduce((a, b) => a + Math.pow(b - data.reduce((c, d) => c + d, 0) / data.length, 2), 0) / (data.length - 1));
                }
                
                // Quick ANOVA
                const allData = simData.flat();
                const simGrandMean = allData.reduce((a, b) => a + b, 0) / allData.length;
                
                let ssBetween = 0;
                let ssWithin = 0;
                
                simData.forEach(group => {
                    const groupMean = group.reduce((a, b) => a + b, 0) / group.length;
                    ssBetween += group.length * Math.pow(groupMean - simGrandMean, 2);
                    group.forEach(value => {
                        ssWithin += Math.pow(value - groupMean, 2);
                    });
                });
                
                const fStat = (ssBetween / (numGroups - 1)) / (ssWithin / (allData.length - numGroups));
                const pValue = 1 - fCDF(fStat, numGroups - 1, allData.length - numGroups);
                
                if (pValue < alpha) typeIErrors++;
            }
            
            // Display assumptions
            const assumptionsDiv = document.getElementById('assumptions');
            assumptionsDiv.style.display = 'block';
            
            const resultsDiv = document.getElementById('assumptionResults');
            resultsDiv.innerHTML = `
                <p><strong>Type I Error Rate:</strong> ${typeIErrors}% (Expected: ${(alpha * 100).toFixed(0)}%)</p>
                <p><strong>Variance Homogeneity:</strong> Max/Min variance ratio = ${(Math.max(...variances) / Math.min(...variances)).toFixed(2)} 
                   ${Math.max(...variances) / Math.min(...variances) < 3 ? '✓ Good' : '⚠ May violate assumption'}</p>
                <p><strong>Sample Size:</strong> ${sampleSize >= 20 ? '✓ Adequate for robustness' : '⚠ Consider larger samples'}</p>
            `;
        }
        
        function calculatePower(etaSquared, n, k, alpha) {
            // Cohen's f from eta squared
            const f = Math.sqrt(etaSquared / (1 - etaSquared));
            
            // Non-centrality parameter
            const lambda = n * f * f;
            
            // Critical F-value
            const dfBetween = k - 1;
            const dfWithin = n - k;
            const fCrit = fInverse(1 - alpha, dfBetween, dfWithin);
            
            // Approximate power (simplified)
            const power = 1 - fCDF(fCrit, dfBetween, dfWithin, lambda);
            
            document.getElementById('power').textContent = (power * 100).toFixed(1) + '%';
        }
        
        function drawBoxPlot() {
            const canvas = document.getElementById('chart');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (groupData.length === 0) return;
            
            const padding = 60;
            const boxWidth = (canvas.width - 2 * padding) / (groupData.length * 2);
            const maxValue = Math.max(...groupData.flatMap(g => g.data));
            const minValue = Math.min(...groupData.flatMap(g => g.data));
            const range = maxValue - minValue;
            const chartHeight = canvas.height - 2 * padding;
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            // Y-axis labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const value = minValue + (range * i / 5);
                const y = canvas.height - padding - (chartHeight * i / 5);
                ctx.fillText(value.toFixed(1), padding - 10, y);
            }
            
            // Draw box plots
            groupData.forEach((group, index) => {
                const x = padding + (index * 2 + 1) * boxWidth;
                const sortedData = [...group.data].sort((a, b) => a - b);
                
                // Calculate quartiles
                const q1 = sortedData[Math.floor(sortedData.length * 0.25)];
                const median = sortedData[Math.floor(sortedData.length * 0.5)];
                const q3 = sortedData[Math.floor(sortedData.length * 0.75)];
                const iqr = q3 - q1;
                const whiskerMin = Math.max(minValue, q1 - 1.5 * iqr);
                const whiskerMax = Math.min(maxValue, q3 + 1.5 * iqr);
                
                // Scale to canvas
                const yQ1 = canvas.height - padding - ((q1 - minValue) / range) * chartHeight;
                const yMedian = canvas.height - padding - ((median - minValue) / range) * chartHeight;
                const yQ3 = canvas.height - padding - ((q3 - minValue) / range) * chartHeight;
                const yWhiskerMin = canvas.height - padding - ((whiskerMin - minValue) / range) * chartHeight;
                const yWhiskerMax = canvas.height - padding - ((whiskerMax - minValue) / range) * chartHeight;
                
                // Draw box
                ctx.fillStyle = colors[index % colors.length] + '40';
                ctx.fillRect(x - boxWidth/2, yQ3, boxWidth, yQ1 - yQ3);
                ctx.strokeStyle = colors[index % colors.length];
                ctx.lineWidth = 2;
                ctx.strokeRect(x - boxWidth/2, yQ3, boxWidth, yQ1 - yQ3);
                
                // Draw median line
                ctx.beginPath();
                ctx.moveTo(x - boxWidth/2, yMedian);
                ctx.lineTo(x + boxWidth/2, yMedian);
                ctx.stroke();
                
                // Draw whiskers
                ctx.beginPath();
                ctx.moveTo(x, yQ1);
                ctx.lineTo(x, yWhiskerMin);
                ctx.moveTo(x - boxWidth/4, yWhiskerMin);
                ctx.lineTo(x + boxWidth/4, yWhiskerMin);
                ctx.moveTo(x, yQ3);
                ctx.lineTo(x, yWhiskerMax);
                ctx.moveTo(x - boxWidth/4, yWhiskerMax);
                ctx.lineTo(x + boxWidth/4, yWhiskerMax);
                ctx.stroke();
                
                // Draw outliers
                ctx.fillStyle = colors[index % colors.length];
                sortedData.forEach(value => {
                    if (value < whiskerMin || value > whiskerMax) {
                        const y = canvas.height - padding - ((value - minValue) / range) * chartHeight;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                });
                
                // Group label
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(group.name, x, canvas.height - padding + 20);
            });
            
            // Title
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Box Plot of Groups', canvas.width / 2, padding - 20);
        }
        
        // Statistical functions
        function fCDF(f, df1, df2, ncp = 0) {
            // Simplified F-distribution CDF (central F only for now)
            if (ncp !== 0) {
                // Non-central F approximation
                return fCDF(f * df1 / (df1 + ncp), df1, df2);
            }
            
            // Using beta distribution relationship
            const x = df1 * f / (df1 * f + df2);
            return betaCDF(x, df1 / 2, df2 / 2);
        }
        
        function fInverse(p, df1, df2) {
            // Approximate F-distribution inverse
            // Using relationship with chi-square
            const z = Math.abs(normalInverse(p));
            const h = 2 / (9 * df1);
            const g = 2 / (9 * df2);
            
            return Math.pow((1 - g + z * Math.sqrt(g)) / (1 - h - z * Math.sqrt(h)), 3);
        }
        
        function betaCDF(x, a, b) {
            // Incomplete beta function approximation
            if (x <= 0) return 0;
            if (x >= 1) return 1;
            
            // Simple approximation for small a, b
            let sum = 0;
            const n = 100;
            for (let i = 0; i <= n; i++) {
                const t = i / n;
                sum += Math.pow(t, a - 1) * Math.pow(1 - t, b - 1);
            }
            
            return sum * x / n / beta(a, b);
        }
        
        function beta(a, b) {
            // Beta function
            return gamma(a) * gamma(b) / gamma(a + b);
        }
        
        function gamma(n) {
            // Stirling's approximation
            if (n < 0.5) return Math.PI / (Math.sin(Math.PI * n) * gamma(1 - n));
            return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n);
        }
        
        function normalInverse(p) {
            // Approximate normal inverse
            const a = [2.50662823884, -18.61500062529, 41.39119773534, -25.44106049637];
            const b = [-8.47351093090, 23.08336743743, -21.06224101826, 3.13082909833];
            const c = [0.3374754822726147, 0.9761690190917186, 0.1607979714918209, 
                      0.0276438810333863, 0.0038405729373609, 0.0003951896511919, 
                      0.0000321767881768, 0.0000002888167364, 0.0000003960315187];
            
            const y = p - 0.5;
            if (Math.abs(y) < 0.42) {
                const r = y * y;
                return y * (((a[3] * r + a[2]) * r + a[1]) * r + a[0]) / 
                          ((((b[3] * r + b[2]) * r + b[1]) * r + b[0]) * r + 1);
            } else {
                let r = p;
                if (y > 0) r = 1 - p;
                r = Math.log(-Math.log(r));
                let x = c[0];
                for (let i = 1; i < 9; i++) {
                    x += c[i] * Math.pow(r, i);
                }
                if (y < 0) x = -x;
                return x;
            }
        }
        
        function getTukeyCritical(k, df, alpha) {
            // Simplified Tukey critical values
            const criticalValues = {
                0.05: {
                    3: { 20: 3.58, 30: 3.49, 60: 3.40 },
                    4: { 20: 3.96, 30: 3.85, 60: 3.74 },
                    5: { 20: 4.23, 30: 4.11, 60: 3.98 }
                },
                0.01: {
                    3: { 20: 4.64, 30: 4.45, 60: 4.28 },
                    4: { 20: 5.02, 30: 4.80, 60: 4.59 },
                    5: { 20: 5.29, 30: 5.05, 60: 4.82 }
                }
            };
            
            const alphaKey = alpha <= 0.01 ? 0.01 : 0.05;
            const dfKey = df <= 20 ? 20 : df <= 30 ? 30 : 60;
            
            return criticalValues[alphaKey][k]?.[dfKey] || 3.5;
        }
        
        // Initialize
        generateData();
        runANOVA();
    </script>
</body>
</html>